import{e as g,y as f,a as Y,H as Z,aA as D,kd as J,ke as K,jS as T,kf as Q,kg as $,k5 as F,kh as U,ki as V,k7 as tt,kj as nt,gv as _,gb as w,gw as d,kk as et,kl as rt,au as ot,k8 as N,km as A,f7 as S,kn as at,ko as it,kp as x,hz as st,bk as z,gj as B,ba as lt,ga as I,h8 as ct,hB as P,jZ as ut,im as v,j_ as pt,j$ as gt,kq as ft,jW as ht,jX as mt,jY as yt,kr as xt,dF as $t,gu as At,ks as wt,kt as vt}from"./index.da161cf1.js";import{m as kt}from"./MeshGeoreferencedRelativeVertexSpace.a44e5587.js";import{m as bt,p as jt}from"./MeshLocalVertexSpace.33b046fb.js";var k;let p=k=class extends Z{constructor(t){super(t),this.translation=D(),this.rotationAxis=J(K),this.rotationAngle=0,this.scale=T(1,1,1)}get rotation(){return Q(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=$(F(t)),this.rotationAngle=U(t)}get localMatrix(){const t=w();return V(O,F(this.rotation),tt(this.rotation)),nt(t,O,this.translation,this.scale),t}get localMatrixInverse(){return _(w(),this.localMatrix)}applyLocal(t,n){return d(n,t,this.localMatrix)}applyLocalInverse(t,n){return d(n,t,this.localMatrixInverse)}equals(t){return this===t||t!=null&&et(this.localMatrix,t.localMatrix)}clone(){const t={translation:$(this.translation),rotationAxis:$(this.rotationAxis),rotationAngle:this.rotationAngle,scale:$(this.scale)};return new k(t)}};g([f({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"translation",void 0),g([f({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"rotationAxis",void 0),g([f({type:Number,nonNullable:!0,json:{write:!0}})],p.prototype,"rotationAngle",void 0),g([f({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"scale",void 0),g([f()],p.prototype,"rotation",null),g([f()],p.prototype,"localMatrix",null),g([f()],p.prototype,"localMatrixInverse",null),p=k=g([Y("esri.geometry.support.MeshTransform")],p);const O=rt(),Mt=p;function q(t,n){return t.isGeographic||t.isWebMercator&&(n?.geographic??!0)}function Ct(t,n,e){const r=!t.isGeoreferenced;e?.geographic!=null&&e.geographic!==r&&ot.getLogger(n).warnOnce(`Specifying the 'geographic' parameter (${e.geographic}) for a Mesh vertex space of type "${t.type}" is not supported. This parameter will be ignored.`)}function j(t,n,e){return q(n.spatialReference,e)?St(t,n,e):Nt(t,n,e)}function G(t,n,e,r){const{position:a,normal:o,tangent:i}=t;if(!n.isRelative)return{position:a,normal:o,tangent:i};const l=e?.localMatrix??A;return j({position:x(new Float64Array(a.length),a,l),normal:o!=null?wt(o,new Float32Array(o.length),l):null,tangent:i!=null?vt(i,new Float32Array(i.length),l):null},n.getOriginPoint(r),{geographic:!n.isGeoreferenced})}function Rt(t,n,e){if(e?.useTransform){const{position:r,normal:a,tangent:o}=t,{x:i,y:l,z:c}=n,s=T(i,l,c??0);return{vertexAttributes:{position:r,normal:a,tangent:o},vertexSpace:e.geographic??1?new bt({origin:s}):new kt({origin:s}),transform:new Mt}}return{vertexAttributes:j(t,n,e),vertexSpace:new jt,transform:null}}function b(t,n,e){return q(n.spatialReference,e)?_t(t,n,e):L(t,n,e)}function Ft(t,n,e,r,a){if(!n.isRelative)return b(t,r,a);const{spatialReference:o}=r,i=G(t,n,e,o);return r.equals(n.getOriginPoint(o))?L(i,r,a):b(i,r,a)}function dt({positions:t,transform:n,vertexSpace:e,inSpatialReference:r,outSpatialReference:a,outPositions:o,local:i}){const l=e.isRelative?e.origin:N,c=e.isRelative?n?.localMatrix??A:A;if(e.isGeoreferenced){const u=o??S(t.length);if(at(c,A)?it(u,t):x(u,t,c),!st(l,N)){const[E,H,X]=l;for(let y=0;y<u.length;y+=3)u[y]+=E,u[y+1]+=H,u[y+2]+=X}return z(u,r,0,u,a,0,u.length/3),u}const s=B(r),R=!i&&lt(r,s)?s:r;I(r,l,h,R),ct(h,h,c);const m=o??S(t.length);return x(m,t,h),z(m,R,0,m,a,0,m.length/3),m}function Nt(t,n,e){const r=new Float64Array(t.position.length),a=t.position,o=n.x,i=n.y,l=n.z??0,c=M(e?e.unit:null,n.spatialReference);for(let s=0;s<a.length;s+=3)r[s]=a[s]*c+o,r[s+1]=a[s+1]*c+i,r[s+2]=a[s+2]*c+l;return{position:r,normal:t.normal,tangent:t.tangent}}function St(t,n,e){const r=n.spatialReference,a=W(n,e,h),o=new Float64Array(t.position.length),i=zt(t.position,a,r,o),l=P(C,a);return{position:i,normal:Ot(i,o,t.normal,l,r),tangent:Tt(i,o,t.tangent,l,r)}}function zt(t,n,e,r){x(r,t,n);const a=new Float64Array(t.length);return ut(r,a,e)}function Ot(t,n,e,r,a){if(e==null)return null;const o=new Float32Array(e.length);return v(o,e,r),pt(o,t,n,a,o),o}function Tt(t,n,e,r,a){if(e==null)return null;const o=new Float32Array(e.length);v(o,e,r,4);for(let i=3;i<o.length;i+=4)o[i]=e[i];return gt(o,t,n,a,o),o}function L(t,n,e){const r=new Float64Array(t.position.length),a=t.position,o=n.x,i=n.y,l=n.z??0,c=M(e?e.unit:null,n.spatialReference);for(let s=0;s<a.length;s+=3)r[s]=(a[s]-o)/c,r[s+1]=(a[s+1]-i)/c,r[s+2]=(a[s+2]-l)/c;return{position:r,normal:t.normal,tangent:t.tangent}}function _t(t,n,e){const r=n.spatialReference;W(n,e,h);const a=_(qt,h),o=new Float64Array(t.position.length),i=Bt(t.position,r,a,o),l=P(C,a);return{position:i,normal:It(t.normal,t.position,o,r,l),tangent:Pt(t.tangent,t.position,o,r,l)}}function W(t,n,e){I(t.spatialReference,[t.x,t.y,t.z??0],e,B(t.spatialReference));const r=M(n?n.unit:null,t.spatialReference);return ft(e,e,[r,r,r]),e}function Bt(t,n,e,r){const a=ht(t,n,r),o=new Float64Array(a.length);return x(o,a,e),o}function It(t,n,e,r,a){if(t==null)return null;const o=mt(t,n,e,r,new Float32Array(t.length));return v(o,o,a),o}function Pt(t,n,e,r,a){if(t==null)return null;const o=yt(t,n,e,r,new Float32Array(t.length));return v(o,o,a,4),o}function M(t,n){if(t==null)return 1;const e=xt(n);return 1/$t(e,"meters",t)}const h=w(),qt=w(),C=At();var Et=Object.freeze(Object.defineProperty({__proto__:null,georeference:j,georeferenceApplyTransform:G,georeferenceByTransform:Rt,project:dt,ungeoreference:b,ungeoreferenceByTransform:Ft},Symbol.toStringTag,{value:"Module"}));export{b as D,Ft as E,dt as I,Mt as N,j as O,G as T,Et as g,Ct as o,Rt as q,q as r};
