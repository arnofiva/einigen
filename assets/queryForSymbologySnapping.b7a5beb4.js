import{gN as D,I as z,aL as C,aM as q,al as v,kH as F,hV as G,kI as O,be as $}from"./index.da161cf1.js";import{u as k}from"./elevationInfoUtils.d710f6c5.js";async function P(o,d,l,I,r){const{elevationProvider:g,renderCoordsHelper:i,spatialReference:m}=o,{elevationInfo:h}=d,y=C(h,!0),b=await q(y,m,r);v(r);const c=[],p=new Set,u=new Set;for(const{objectId:e,points:a}of I){const n=l(e);if(n==null){for(const s of a)c.push(s.z??0);p.add(e);continue}n.isDraped&&u.add(e);const t=n.graphic.geometry;w.setFromElevationInfo(k(t,h)),w.updateFeatureExpressionInfoContext(b,n.graphic,d),f.spatialReference=o.spatialReference;for(const{x:s,y:j,z:x}of a)f.x=s,f.y=j,f.z=x??0,F(f,g,w,i,R),c.push(R.z)}return{elevations:c,drapedObjectIds:u,failedObjectIds:p}}const w=new G,f=D(0,0,0,z.WGS84),R=new O;async function A(o,d,l){if(o==null||d.candidates.length===0)return S;const I=o.graphics3DGraphicsByObjectID??o.graphics3DGraphics,r=[],g=[],{renderer:i}=o,m=i!=null&&"arcadeRequired"in i&&i.arcadeRequired?$():null,h=async(e,{graphic:a,graphics3DSymbol:n})=>{const t=await m,s=await o.getRenderingInfoAsync(a,i,t,{signal:l});return s==null?[]:n.queryForSnapping(e,b,s,l)},{candidates:y,spatialReference:b}=d;for(let e=0;e<y.length;++e){const a=y[e],{objectId:n}=a,t=typeof n=="number"?I?.get(n):void 0;if(t==null)continue;const{graphics3DSymbol:s}=t;s.symbologySnappingSupported&&(r.push(h(a,t)),g.push(e))}if(r.length===0)return S;const c=await Promise.all(r);v(l);const p=[],u=[];for(let e=0;e<c.length;++e){const a=c[e],n=g[e];for(const t of a)p.push(t),u.push(n)}return{candidates:p,sourceCandidateIndices:u}}const S={candidates:[],sourceCandidateIndices:[]};export{P as f,A as r};
