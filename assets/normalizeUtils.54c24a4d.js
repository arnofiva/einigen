import{e5 as T,e6 as U,bZ as X,a0 as F,cC as W,e7 as Z,e8 as _,au as B,e9 as E,ea as G,cD as O,dy as M,j as P,cz as H,a3 as K}from"./index.da161cf1.js";import{r as z,o as A,i as R,s as k}from"./normalizeUtilsCommon.87227ae2.js";async function Q(e,s,f,n){const t=T(e),c=s[0].spatialReference,a={...n,query:{...t.query,f:"json",sr:JSON.stringify(c),target:JSON.stringify({geometryType:U(s[0]),geometries:s}),cutter:JSON.stringify(f)}},o=await X(t.path+"/cut",a),{cutIndexes:u,geometries:y=[]}=o.data;return{cutIndexes:u,geometries:y.map(h=>{const x=F(h);return x.spatialReference=c,x})}}async function V(e,s,f){const n=typeof e=="string"?W(e):e,t=s[0].spatialReference,c=U(s[0]),a={...f,query:{...n.query,f:"json",sr:t.wkid??JSON.stringify(t),geometries:JSON.stringify(Z(s))}},{data:o}=await X(n.path+"/simplify",a);return _(o.geometries,c,t)}const D=B.getLogger("esri.geometry.support.normalizeUtils");function Y(e){return e.type==="polygon"}function ee(e){return e[0].type==="polygon"}function te(e){return e[0].type==="polyline"}function se(e,s){if(!(e instanceof O||e instanceof P)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw D.error(t),new K(t)}const f=A(e),n=[];for(const t of f){const c=[];n.push(c),c.push([t[0][0],t[0][1]]);for(let a=0;a<t.length-1;a++){const o=t[a][0],u=t[a][1],y=t[a+1][0],h=t[a+1][1],x=Math.sqrt((y-o)*(y-o)+(h-u)*(h-u)),l=(h-u)/x,m=(y-o)/x,p=x/s;if(p>1){for(let j=1;j<=p-1;j++){const S=j*s,r=m*S+o,i=l*S+u;c.push([r,i])}const w=(x+Math.floor(p-1)*s)/2,L=m*w+o,I=l*w+u;c.push([L,I])}c.push([y,h])}}return Y(e)?new P({rings:n,spatialReference:e.spatialReference}):new O({paths:n,spatialReference:e.spatialReference})}function v(e,s,f){if(s){const n=se(e,1e6);e=H(n,!0)}return f&&(e=k(e,f)),e}function C(e,s,f){if(Array.isArray(e)){const n=e[0];if(n>s){const t=R(n,s);e[0]=n+t*(-2*s)}else if(n<f){const t=R(n,f);e[0]=n+t*(-2*f)}}else{const n=e.x;if(n>s){const t=R(n,s);e=e.clone().offset(t*(-2*s),0)}else if(n<f){const t=R(n,f);e=e.clone().offset(t*(-2*f),0)}}return e}function ne(e,s){let f=-1;for(let n=0;n<s.cutIndexes.length;n++){const t=s.cutIndexes[n],c=s.geometries[n],a=A(c);for(let o=0;o<a.length;o++){const u=a[o];u.some(y=>{if(y[0]<180)return!0;{let h=0;for(let l=0;l<u.length;l++){const m=u[l][0];h=m>h?m:h}h=Number(h.toFixed(9));const x=-360*R(h,180);for(let l=0;l<u.length;l++){const m=c.getPoint(o,l);c.setPoint(o,l,m.clone().offset(x,0))}return!0}})}if(t===f){if(ee(e))for(const o of A(c))e[t]=e[t].addRing(o);else if(te(e))for(const o of A(c))e[t]=e[t].addPath(o)}else f=t,e[t]=c}return e}async function oe(e,s,f){if(!Array.isArray(e))return oe([e],s);s&&typeof s!="string"&&D.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:s?.url??E.geometryServiceUrl;let t,c,a,o,u,y,h,x,l=0;const m=[],p=[];for(const r of e)if(r!=null)if(t||(t=r.spatialReference,c=G(t),a=t.isWebMercator,y=a?102100:4326,o=z[y].maxX,u=z[y].minX,h=z[y].plus180Line,x=z[y].minus180Line),c)if(r.type==="mesh")p.push(r);else if(r.type==="point")p.push(C(r.clone(),o,u));else if(r.type==="multipoint"){const i=r.clone();i.points=i.points.map(g=>C(g,o,u)),p.push(i)}else if(r.type==="extent"){const i=r.clone()._normalize(!1,!1,c);p.push(i.rings?new P(i):i)}else if(r.extent){const i=r.extent,g=R(i.xmin,u)*(2*o);let d=g===0?r.clone():k(r.clone(),g);i.offset(g,0),i.intersects(h)&&i.xmax!==o?(l=i.xmax>l?i.xmax:l,d=v(d,a),m.push(d),p.push("cut")):i.intersects(x)&&i.xmin!==u?(l=i.xmax*(2*o)>l?i.xmax*(2*o):l,d=v(d,a,360),m.push(d),p.push("cut")):p.push(d)}else p.push(r.clone());else p.push(r);else p.push(r);let w=R(l,o),L=-90;const I=w,j=new O;for(;w>0;){const r=360*w-180;j.addPath([[r,L],[r,-1*L]]),L*=-1,w--}if(m.length>0&&I>0){const r=ne(m,await Q(n,m,j,f)),i=[],g=[];for(let $=0;$<p.length;$++){const N=p[$];if(N!=="cut")g.push(N);else{const q=r.shift(),b=e[$];b!=null&&b.type==="polygon"&&b.rings&&b.rings.length>1&&q.rings.length>=b.rings.length?(i.push(q),g.push("simplify")):g.push(a?M(q):q)}}if(!i.length)return g;const d=await V(n,i,f),J=[];for(let $=0;$<g.length;$++){const N=g[$];N!=="simplify"?J.push(N):J.push(a?M(d.shift()):d.shift())}return J}const S=[];for(let r=0;r<p.length;r++){const i=p[r];if(i!=="cut")S.push(i);else{const g=m.shift();S.push(a===!0?M(g):g)}}return S}export{oe as b};
